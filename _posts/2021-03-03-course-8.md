---
title: 'Kotlin学习笔记（8） - 扩展'
author: litao
date: 2021-03-03 19:24:00 +0800
categories: [Kotlin,Course]
tags: [Course,Kotlin]





---

## 一、扩展函数

Kotlin中可以对一个类或接口扩展新功能而无需继承或类似*Decorator*对设计模式，例如我们希望对一些三方库中的类或接口添加新方法，调用方式可以与原始方法一致。

定义时用适用被扩展类型为前缀加扩展的方法名即可，函数内部`this`指扩展类

```kotlin
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
```

也可以直接使用泛型，将对任何`MutableList<T>`类型生效

```kotlin
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}

val list = mutableListOf(1, 2, 3)
list.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'
```

通常还可以定义为可空接收，内部通过`this == null`进行校验

```kotlin
fun Any?.toString(): String {
    if (this == null) return "null"
    // After the null check, 'this' is autocast to a non-nullable type, so the toString() below
    // resolves to the member function of the Any class
    return toString()
}
```

## 二、扩展属性

像扩展函数一样，Kotlin同样支持扩展属性，扩展函数没有[backing field](https://kotlinlang.org/docs/properties.html#backing-fields) 不允许使用设定初始值，只能通过显式的getter/setter来实现。

```kotlin
val <T> List<T>.lastIndex: Int
    get() = size - 1
```

下面这样是错误的，不能知道设定初始值

```kotlin
val House.number = 1 // 错误：扩展属性不能有初始化器
```

## 三、伴生对象的扩展

伴生对象也可以直接定义扩展函数或属性，调用是与伴生对象的常规成员一样。

```kotlin
class MyClass {
    companion object { }  // 将被称为 "Companion"
}

fun MyClass.Companion.printCompanion() { println("companion") }

fun main() {
    MyClass.printCompanion()
}
```

## 四、声明为类成员

可以在另一个类中声明当前类的扩展，仅在声明的当前作用域内有效。

```kotlin
class Host(val hostname: String) {
    fun printHostname() { print(hostname) }
}

class Connection(val host: Host, val port: Int) {
    fun printPort() { print(port) }

    fun Host.printConnectionString() {
        printHostname()   // calls Host.printHostname()
        print(":")
        printPort()   // calls Connection.printPort()
    }

    fun connect() {
        /*...*/
        host.printConnectionString()   // calls the extension function
    }
}

fun main() {
    Connection(Host("kotl.in"), 443).connect()
    //Host("kotl.in").printConnectionString()  // error, the extension function is unavailable outside Connection
}
```

如果扩展内部存在调用冲突则使用`this`关键字进行限定

```kotlin
class Connection {
    fun Host.getConnectionString() {
        toString()         // calls Host.toString()
        this@Connection.toString()  // calls Connection.toString()
    }
}
```

声明为成员扩展的可用`open`关键字进行修饰，子类中可以进行重写

```kotlin
open class Base { }

class Derived : Base() { }

open class BaseCaller {
    open fun Base.printFunctionInfo() {
        println("Base extension function in BaseCaller")
    }

    open fun Derived.printFunctionInfo() {
        println("Derived extension function in BaseCaller")
    }

    fun call(b: Base) {
        b.printFunctionInfo()   // call the extension function
    }
}

class DerivedCaller: BaseCaller() {
    override fun Base.printFunctionInfo() {
        println("Base extension function in DerivedCaller")
    }

    override fun Derived.printFunctionInfo() {
        println("Derived extension function in DerivedCaller")
    }
}

fun main() {
    BaseCaller().call(Base())   // "Base extension function in BaseCaller"
    DerivedCaller().call(Base())  // "Base extension function in DerivedCaller" - dispatch receiver is resolved virtually
    DerivedCaller().call(Derived())  // "Base extension function in DerivedCaller" - extension receiver is resolved statically
}
```

